    const elk = new ELK()

    const graph = {
      id: "root",
      layoutOptions: { 'elk.algorithm': 'layered',
        'elk.spacing.nodeNode':""+this.optionsForChild.width/10,
        'elk.layered.spacing.nodeNodeBetweenLayers': ""+this.optionsForChild.width/2,
        // 'elk.separateConnectedComponents': 'false',
        // 'elk.layered.crossingMinimization.semiInteractive': 'true',
        'aspectRatio':'0.09',
        'elk.direction':'RIGHT',
      },
      children: this.s_blocks.map( (block) => {
        return {
          id: "n"+block.id,
          width: this.optionsForChild.width,
          height: 100,
          layoutOptions: {
            'elk.position': Object.keys(block.outputLinks).length>0?'(0,0)':'(0,1)',
            portConstraints: "FIXED_POS"
          },
          ports: this.blockTypes[block.type].inputs.map( (port,index) => {
            return {
              "id": `p_${block.id}_${index}`,
              "y":index*10
            }
          })
        }
      }),
      edges: this.s_links.map ( (link) => {
        return {
          id: "e"+link.originId+"_"+link.targetId,
          sources: ["n"+link.originId],
          targets: [`p_${link.targetId}_${link.targetSlot}`]
        }
      })
    }
    let layout = await elk.layout(graph)
    console.log(layout)
    for (let node of layout.children) {
      // reposition the node
      let blockIndex = this.s_blocks.findIndex( (block) => block.id==parseInt(node.id.substring(1)))
      this.$set(
        this.s_blocks,
        blockIndex,
        Object.assign({},this.s_blocks[blockIndex],{
          "x":node.x,
          "y":node.y
        })
      )
    }
    this.updateBlocks()
